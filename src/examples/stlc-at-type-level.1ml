;; 1ML basically gives you simply typed lambda calculus (STLC) at the type
;; level, which is unsurprising as 1ML is just as powerful as FÏ‰.  You can even
;; use lambda and let -expressions at the type level (note the `fst` and `snd`
;; definitions below).  So, you can Church and Scott encode various kinds of
;; stuff at the type level.  Of course, STLC is quite restrictive.

STLC_At_Type_Level = {

  ;; The type `type` is also not special.  We can give a new name to it:
  type T = type;

  type id (t: T) = t;
  type const (t: T) (_: T) = t;
  type compose (f: T => T) (g: T => T) (t: T) = f (g t);

  Pair = {
    type pair = (T => T => T) => T;

    type fst (p: pair) = p (fun (t: T) (_: T) => t);
    type snd (p: pair) = p (fun (_: T) (t: T) => t);

    type mk (t1: T) (t2: T) (d: T => T => T) = d t1 t2;

    type cross (f: T => T) (s: T => T) (p: pair) (d: T => T => T) =
      mk (f (fst p)) (s (snd p)) d;

    type map (f: T => T) (p: pair) (d: T => T => T) = cross f f p d;
  };

  Bool = {
    type bool = T => T => T;

    type t (t: T) (_: T) = t;
    type f (_: T) (f: T) = f;

    type not (b: bool) (t: T) (f: T) = b f t;
  };

  Alt = {
    type alt = (T => T) => (T => T) => T;

    type inl (t: T) (onl: T => T) ( _ : T => T) = onl t;
    type inr (t: T) ( _ : T => T) (onr: T => T) = onr t;

    type isl (a: alt) (t: T) (f: T) = a (const t) (const f);
    type isr (a: alt) (t: T) (f: T) = a (const f) (const t);

    type case (a: alt) (onl: T => T) (onr: T => T) = a onl onr;
  };

  Nat = {
    type nat = (T => T) => T => T;

    type  zero                   (_: T => T) (t: T) = t;
    type   inc          (n: nat) (f: T => T) (t: T) = f (n f t);
    type  plus (m: nat) (n: nat) (f: T => T) (t: T) = n f (m f t);
    type times (m: nat) (n: nat) (f: T => T) (t: T) = n (m f) t;

    type isZero (n: nat) (t: T) (f: T) = n (const f) t;
  };

};
